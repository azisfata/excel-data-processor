const handleAutoFillFromFiles = useCallback(async () => {
    setAiAutofillError(null);
    setAiAutofillSuccess(null);

    const initialSteps: AiAutofillStep[] = [
      { label: 'Mengumpulkan teks dari lampiran', status: 'processing' },
      { label: 'Mengirim permintaan ke AI', status: 'processing' },
    ];
    setAiAutofillSteps(initialSteps);

    const pdfFiles = newAttachmentFiles.filter(file => {
      const name = file.name.toLowerCase();
      return file.type === 'application/pdf' || name.endsWith('.pdf');
    });

    if (pdfFiles.length === 0) {
      setAiAutofillSteps([
        {
          label: 'Mengumpulkan teks dari lampiran',
          status: 'error',
          detail: 'Unggah minimal satu file PDF agar AI dapat membaca isi dokumen.',
        },
      ]);
      setAiAutofillError('Unggah minimal satu dokumen PDF terlebih dahulu untuk digunakan oleh AI.');
      return;
    }

    setIsAiAutofilling(true);

    const updateStep = (index: number, patch: Partial<AiAutofillStep>) => {
      setAiAutofillSteps(prev => prev.map((step, idx) => (idx === index ? { ...step, ...patch } : step)));
    };

    try {
      let combinedText = '';
      for (let i = 0; i < pdfFiles.length; i += 1) {
        const file = pdfFiles[i];
        updateStep(0, {
          detail: `Membaca ${file.name} (${i + 1} dari ${pdfFiles.length})`,
        });
        try {
          const extractedText = await extractTextFromPdf(file);
          if (extractedText) {
            combinedText += `\n\n==== ${file.name} ====\n${extractedText}`;
          }
        } catch (extractionError) {
          console.warn(`Gagal mengekstrak teks dari ${file.name}`, extractionError);
        }
      }

      if (!combinedText.trim()) {
        updateStep(0, {
          status: 'error',
          detail: 'Tidak ada teks yang berhasil diambil dari lampiran PDF.',
        });
        throw new Error('Tidak ada teks yang berhasil diambil dari lampiran.');
      }

      updateStep(0, {
        status: 'success',
        detail: `Berhasil mengumpulkan teks dari ${pdfFiles.length} file PDF`,
      });

      const truncated = combinedText.slice(0, 15000);
      const systemMessage =
        'Anda adalah asisten yang mengekstrak informasi kegiatan dari dokumen resmi. ' +
        'Jawab hanya dengan JSON valid tanpa teks tambahan.';

      const userMessage = [
        'Berdasarkan kumpulan dokumen berikut, isi field kegiatan yang tersedia. Gunakan format tanggal YYYY-MM-DD.',
        'Jika informasi tidak ditemukan, biarkan field kosong atau null.',
        'Gunakan struktur JSON berikut:',
        '{',
        '  "nama": string | null,',
        '  "status": string | null,',
        '  "tanggal": string | null,',
        '  "tujuan": string | null,',
        '  "unitTerkait": string | null,',
        '  "penanggungJawab": string | null,',
        '  "capaian": string | null,',
        '  "pendingIssue": string | null,',
        '  "rencanaTindakLanjut": string | null,',
        '  "allocations": [',
        '    { "kode": string, "uraian": string | null, "jumlah": number | null }',
        '  ]',
        '}',
        '',
        'Kumpulan dokumen:',
        truncated,
      ].join('\n');

      updateStep(1, { detail: 'Mengirim permintaan ke model AIï¿½' });

      const aiResponse = await fetchAiResponse([
        { role: 'system', content: systemMessage },
        { role: 'user', content: userMessage },
      ]);
      const modelUsed = getLastSuccessfulModel() ?? 'tidak diketahui';
      console.log('AI autofill menggunakan model:', modelUsed);

      const cleaned = aiResponse.replace(/```json|```/g, '').trim();
      const parsed = JSON.parse(cleaned);

      setNewActivity(prev => ({
        ...prev,
        nama: parsed.nama ?? prev.nama,
        status: parsed.status ?? prev.status ?? 'Rencana',
        tanggal_pelaksanaan: parsed.tanggal ?? prev.tanggal_pelaksanaan,
        tujuan_kegiatan: parsed.tujuan ?? prev.tujuan_kegiatan,
        kl_unit_terkait: parsed.unitTerkait ?? prev.kl_unit_terkait,
        penanggung_jawab: parsed.penanggungJawab ?? prev.penanggung_jawab,
        capaian: parsed.capaian ?? prev.capaian,
        pending_issue: parsed.pendingIssue ?? prev.pending_issue,
        rencana_tindak_lanjut: parsed.rencanaTindakLanjut ?? prev.rencana_tindak_lanjut,
      }));

      if (Array.isArray(parsed.allocations)) {
        const normalizedAllocations = parsed.allocations
          .map((item: any) => ({
            kode: typeof item.kode === 'string' ? item.kode.trim() : '',
            uraian: typeof item.uraian === 'string' ? item.uraian.trim() : '',
            jumlah: Number(item.jumlah) || 0,
          }))
          .filter(item => item.kode);

        if (normalizedAllocations.length > 0) {
          setNewActivity(prev => ({
            ...prev,
            allocations:
              prev.allocations && prev.allocations.length > 0
                ? prev.allocations
                : normalizedAllocations,
          }));
        }
      }

      updateStep(1, {
        status: 'success',
        detail: `Respons AI (${modelUsed}) diterima. Field telah diisi, mohon ditinjau.`,
      });

      setAiAutofillSuccess(`Field berhasil diisi dari ${pdfFiles.length} dokumen. Mohon tinjau sebelum menyimpan.`);
    } catch (error) {
      console.error('AI autofill error:', error);
      const message = error instanceof Error ? error.message : 'Gagal mengisi form dengan AI.';
      updateStep(1, {
        status: 'error',
        detail: message,
      });
      setAiAutofillError(message);
    } finally {
      setIsAiAutofilling(false);
    }
  }, [extractTextFromPdf, newAttachmentFiles]);

  